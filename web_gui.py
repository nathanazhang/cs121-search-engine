"""
This code was mainly generated by AI
and then manually edited to fit assignment specifications.
"""

from flask import Flask, request, render_template_string   # Flask handles HTTP requests + HTML rendering
import time                                                # used for query latency measurement

from search_engine import compute_scores, load_metadata, doc_meta  # core search engine functions + metadata
from analytic_query import record_query_time                        # logs query analytics

from config import (
    WEB_HOST,                                              # host address (e.g., "127.0.0.1")
    WEB_PORT,                                              # port number (e.g., 5000)
    DEBUG_MODE                                             # Flask debug mode toggle
)

app = Flask(__name__)                                      # create Flask application instance

# HTML template for rendering search results (embedded directly as a string)
HTML_TEMPLATE = """
<!doctype html>
<html>
<head>
  <title>ICS Search Engine</title>
</head>
<body>
  <h1>ICS Search Engine</h1>
  <form method="GET">  <!-- GET request so query appears in URL -->
    <input type="text" name="q" value="{{ query|e }}" style="width: 400px;" />  <!-- user query box -->
    <button type="submit">Search</button>  <!-- submit button -->
  </form>

  {% if query %}  <!-- only show results if user typed something -->
    <h2>Results for "{{ query|e }}"</h2>

    {% if query_time_ms is not none %}
      <p>Query time: {{ query_time_ms }} ms</p>  <!-- display latency -->
    {% endif %}

    <ol>
    {% for r in results %}  <!-- loop through ranked results -->
      <li>
        <a href="{{ r.url }}" target="_blank">{{ r.url }}</a>  <!-- clickable result URL -->
        <div>Score: {{ "%.4f"|format(r.score) }}</div>  <!-- show ranking score -->
      </li>
    {% endfor %}
    </ol>
  {% endif %}
</body>
</html>
"""

@app.route("/", methods=["GET"])                           # root URL handles search requests
def search_page():
    q = request.args.get("q", "").strip()                 # extract ?q=... from URL, default empty
    results_view = []                                     # list of results to pass to template
    query_time_ms = None                                  # will store query latency

    if q:                                                 # only run search if query is non-empty
        start = time.perf_counter()                       # start timer for analytics
        ranked = compute_scores(q)                        # call search engine ranking function
        elapsed_ms = (time.perf_counter() - start) * 1000 # compute latency in milliseconds
        query_time_ms = round(elapsed_ms, 2)              # round for display

        record_query_time(elapsed_ms)                     # log query time to analytics

        for doc_id, score in ranked:                      # convert internal results to display format
            meta = doc_meta[str(doc_id)]                  # lookup metadata for each doc
            results_view.append({"url": meta["url"], "score": score})  # store URL + score

    return render_template_string(                        # render HTML template with variables
        HTML_TEMPLATE,
        query=q,                                          # user query
        results=results_view,                             # ranked results
        query_time_ms=query_time_ms                       # latency
    )

if __name__ == "__main__":
    print("Starting search engine... (may take a few minutes)")  # user-friendly startup message
    load_metadata()                                              # load lexicon + doc metadata into memory
    print("--------------------------------------------------------------------------------")
    app.run(host=WEB_HOST, port=WEB_PORT, debug=DEBUG_MODE)      # start Flask web server
